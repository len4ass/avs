## Отчет об ИДЗ #1

### Примечание
Программа изначально написана на ассемблере (вручную). Затем была написана аналогичная программа на С.
Исходный код и скомпилированная программа на ассемблере находится в папке *asm_program*, скомпилировать самостоятельно ее можно зайдя в папку *asm_program* и запустив скрипт `./compile_asm.sh` (либо запустить уже скомпилированную программу `./asm_program`).

Исходный код и скомпилированная программа на С находится в папке *c_program/c_program_optimizations*, скомпилировать ее можно либо с помощью gcc `gcc c_program.c -o c_program`, либо запустив скрипт `./compile_all_optimizations.sh` -- он выдаст программы с разными уровнями оптимизации (либо запустить уже скомпилированную программу `./c_program`).

Компиляция выполнялась на WSL2 Ubuntu с помощью `as`, `gcc` и `g++` для тестирующей программы.

**Выполнены требования на 9 баллов, каждая строчка ассемблерной программы прокомментирована  
Чтение/запись более миллиона чисел будет выполняться довольно долго**

### How to use
Есть несколько способов запуска программы:
1) `./asm_program` - стандартный запуск программы, при котором от пользователя потребуется ввести размер массива с консоли, а также его элементы поочередно. После того, как программа закончит работу, в консоль вывыдется преобразованный массив, а затем тот, что был введен изначально. При этом, максимальный размер массива ограничен 1 миллионом. При попытке ввода неположительного или превышающего 1 миллион числа будет выдана ошибка.
![First type](https://i.imgur.com/bFdRuRW.png)
2) `./asm_program -g` - запуск программы, при котором генерируется размер массива и наполнение массива. Размер массива будет лежать в рамках [1, 1000000]. После генерации массива и его преобразования оба массива будут записаны в файлы. Сгенерированный массив будет записан в `gen_array.txt`, преобразованный массив в `transformed_gen_array.txt`. Формат записи чисел через пробел: `размер число_1 число_2 ... последнее_число`
![Second type](https://i.imgur.com/jYhUg1X.png)
3) `./asm_program -g value` - запуск программы, при котором размер генерируемого массива задается в качестве аргумента `value` - целого положительного числа. В данном случае генерируется массив строго заданного размера. Если размер неположителен или больше 1 миллиона, будет выдана ошибка. Сгенерированный массив будет записан в `gen_array.txt`, преобразованный -- в `transformed_gen_array.txt`. Формат записи чисел через пробел: `размер число_1 число_2 ... последнее_число`
![Third type](https://i.imgur.com/thRxkoj.png)
4) `./asm_program -f input.txt output.txt` - запуск программы, при котором входной массив подается через файл `input.txt`, а преобразованный в файл `output.txt`. При отсутствии `input.txt` или других проблемах программа выведет "Failed to read array from file". Формат входного файла: `размер число_1 число_2 ... последнее число`. Формат выходного файла: `размер новое_число_1 новое_число_2 ... новое_последнее_число`. Название файлов может быть любым, главное чтобы входной файл существовал.
![Fourth type](https://i.imgur.com/FRYa1P6.png)

Проверяется только количество переданных аргументов при запуске программы, сами переданные ключи не проверяются. Если входных аргументов будет больше 4, то программа осуществит стандартный запуск с вводом с консоли.

### Оптимизации 
#### Память
Использованные опции компиляции для ассемблерной программы: `as main.asm -o asm_program.o && gcc asm_program.o -o asm_program` (см. файл `asm_program/compile_asm.sh`)

Использованные опции компиляции для программы на С: `gcc c_program.c -o c_program  && gcc c_program.c -O0 -o c_program_O0 && gcc c_program.c -O1 -o c_program_O1 && gcc c_program.c -O2 -o c_program_O2 && gcc c_program.c -O3 -o c_program_O3 && gcc c_program.c -Ofast -o c_program_Ofast && gcc c_program.c -Os -o c_program_Os` (см. файл `c_program/c_program_optimizations/compile_all_optimizations.sh`)

Использование разных опций компиляции никак не уменьшают место, занимаемое программой - даже наоборот.

![Memory](https://i.imgur.com/tRNisJ0.png)

Примечательно, что компиляция с флагом `-0s`, направленная на уменьшение размера исполняемого файла, тоже делает хуже.

![Memory on -Os](https://i.imgur.com/xtshAVB.png)

Самый большой объем оказался у программы, скомпилированной с флагом `-Ofast`, написанная вручную программа на ассемблере немного выигрывает.

![Memory on asm](https://i.imgur.com/XGl2cuY.png)

#### Ассемблерный листинг
Программа, написанная вручную на ассемблере максимально использует регистры, что значительно ускоряет время работы. Смысла сравнивать ассемблерный листинг Сишной программы с разными опциями компиляции просто нет, поскольку там компилятор не пытается использовать векторные инструкции, а также пытается использовать регистры.

#### Время
Замерять исполнение целой программы не очень корректно, даже в случае когда ввод/вывод осуществляется с помощью файлов, поскольку это очень времязатратная операция, поэтому будем тестировать функцию *transform_array*, которая преобразует массив. Для этого нужно создать объектные файлы, в которых каждая функция скомпилированы с разными оптимизациями.  

Для ассемблерной программы возьмем файл *transform_array.asm* из папки *asm_program*, добавим в его начале `.global transform_array` (чтобы функция была доступна при линковке из-вне), а затем создадим объектный файл командой `as -msyntax=intel -mnaked-reg transform_array.asm -o array_func_asm.o` (либо запустим скрипт `./create_array_func_object_file.sh`). Перенесем полученный файл в папку *run_tests*.  

Для программы на С создадим разные файлы в папке *c_program/array_func_object_files*, в которых название функции и файла будет отражать уровень оптимизаций. Создадим объектные файлы, запустив скрипт `./prepare_object_files.sh` (см. этот скрипт, чтобы увидеть все команды). Затем переместим полученные объектные файлы в папку *run_tests*.

Теперь нужно написать небольшую программу на С++, которая будет брать функции из объектных файлов и тестировать их. Подробный код доступен в исходном файле *run_tests.cpp*. Скомпилировать его, чтобы подтянуть функции можно командой `g++ -std=c++2a run_tests.cpp array_func_asm.o array_func_C_st.o array_func_C_O0.o array_func_C_O1.o array_func_C_O2.o array_func_C_O3.o array_func_C_Ofast.o -o run_tests` (или запустить скрипт `./compile_tester.sh`).

Данная программа тестирует функции на наборе входных данных несколько раз, выдает среднее значение в миллисекундах на протестированном наборе, а также отклонение среднего значения от максимального в процентах. Для более точного результата используются большие сгенерированные массивы:
1) Массив размера 50 миллионов чисел (int64_t), тестируется 25 раз
2) Массив размера 100 миллионов чисел (int64_t), тестируется 10 раз
3) Массив размера 250 миллионов чисел (int64_t), тестируется 5 раз

Если вы желаете перепроверить работу программы, убедитесь что на вашей системе есть возможность выделения до 2 гигабайт памяти с помощью malloc. Если вы не можете выделить столько памяти, то в исходном коде тестирующей программы достаточно заменить размер генерируемого массива в функции main.
![main.cpp](https://i.imgur.com/hZL4kzE.png)

Запустим программу - `./run_tests`

![Test results](https://i.imgur.com/T4Cfo1s.png)

Как можем видеть, написанная на ассемблере вручную программа держится на равне с оптимизациями `-O3` и `-Ofast`, при этом среднее значение меньше всех отклоняется от максимального.

### Файловые наборы тестовых данных (случайные и ручные)
Файлы с тестовыми данными и выводом находятся в папке *run_tests/file_tests*

### Случайные наборы тестовых данных
Файлы с результатом работы на случайных наборах находятся в папке *run_tests/random_tests*