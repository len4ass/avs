## Отчет об ИДЗ #2, вариант 3

### Примечание
Программа изначально написана на ассемблере (вручную). Затем была написана аналогичная программа на С.
Исходный код и скомпилированная программа на ассемблере находится в папке *asm_program*, скомпилировать самостоятельно ее можно зайдя в папку *asm_program* и запустив скрипт `./compile_asm.sh` (либо запустить уже скомпилированную программу `./asm_program`).

Исходный код и скомпилированная программа на С находится в папке *c_program/c_program_optimizations*, скомпилировать ее можно либо с помощью gcc `gcc c_program.c -o c_program`, либо запустив скрипт `./compile_all_optimizations.sh` -- он выдаст программы с разными уровнями оптимизации (либо запустить уже скомпилированную программу `./c_program`).

Компиляция выполнялась на WSL2 Ubuntu с помощью `as`, `gcc` и `g++` для тестирующей программы.

**P.S.:**
1) Выполнены требования на 9 баллов, каждая строчка ассемблерной программы прокомментирована  
2) Размер читаемых строк не ограничен, кроме того, сколько памяти сможет выделить malloc (не рекомендуется пытаться выделить более 2 гигабайт).
3) Для генерации строк используется диапазон [32, 126] ASCII-таблицы, чтобы при ручном чтении файлов можно было понять, каков результат.
4) Ввод строк с консоли завершается при вводе '\n', '\0', EOF; если вы желаете ввести строку и чтобы '\n' содержался в этой строке, используйте ввод с файлов. При вводе с файлов ввод завершить либо при первом встреченном '\0', либо при EOF
### How to use
Есть несколько способов запуска программы:
1) `./asm_program` - стандартный запуск программы, при котором от пользователя потребуется ввести длину искомой последовательности с консоли, а также саму строку. Строка читается до '\n' или '\0' или EOF. После того, как программа закончит работу, в консоль вывыдется последовательность указанной длины, если она была найдена, иначе соответствующую ошибку.
![First type (valid)](https://i.imgur.com/cvYifjF.png)
![First type (invalid 1)](https://i.imgur.com/sF0vu2B.png)
![First type (invalid 2)](https://i.imgur.com/qdrEuPo.png)
2) `./asm_program -g` - запуск программы, при котором генерируется размер строки и длина искомой последовательности. Размер строки ограничен и будет лежать в рамках [1, 1000000]. Длина искомой последовательности ограничена и будет лежать в диапазоне [1, 20]. После генерации и поиска сгенерированная строка будет записана в `generated_string.txt`, а найденная последовательность в `sequence.txt`. Если найти последовательность сгенерированной длины не удалось, то будет выведена соответствующая ошибка в консоль.
![Second type (valid)](https://i.imgur.com/zolqD7S.png)
![Second type (invalid 1)](https://i.imgur.com/Qx87klw.png)
![Second type (invalid 2)](https://i.imgur.com/aLN9KxS.png)
3) `./asm_program -g string_size` - запуск программы, при котором размер генерируемой строки задается в качестве аргумента `string_size` - целого положительного числа. В данном случае генерируется строка строго заданного размера. Если размер неположителен, то будет выдана ошибка. В случае, если заданный размер больше миллиона, будет взято значение по модулю 1000001. Длина искомой последовательности генерируется в рамках [1, 20]. После генерации и поиска сгенерированная строка будет записана в `generated_string.txt`, а найденная последовательность в `sequence.txt`. Если найти последовательность сгенерированной длины не удалось, то будет выведена соответствующая ошибка в консоль.
![Third type (valid)](https://i.imgur.com/grQKpgM.png)
![Third type (invalid 1)](https://i.imgur.com/jPW03wz.png)
![Third type (invalid 2)](https://i.imgur.com/Blx4z0P.png)
4) `./asm_program -g string_size sequence_length` - запуск программы, при котором размер генерируемой строки задается в качестве аргумента `string_size`, а длина искомой последовательности в качестве аргумента `sequence_length` - целых положительных чисел. Если размер или длина неположительны, то будет выдана ошибка. В случае, если размер превышает 1000000 или длина превышает 20, будут взяты значения по модулям 1000001 и 20 соответственно. После генерации и поиска сгенерированная строка будет записана в `generated_string.txt`, а найденная последовательность в `sequence.txt`. Если найти последовательность указанной длины в строке указанного размера найти не удалось, то будет выведена соответствующая ошибка.
![Fourth type (valid)](https://i.imgur.com/Pyozumc.png)
![Fourth type (invalid 1)](https://i.imgur.com/q52Mr1s.png)
![Fourth type (invalid 2)](https://i.imgur.com/4bwNEzx.png)
5) `./asm_program -f input.txt output.txt` - запуск программы, при котором строка и длина последовательности подаются через `input.txt`, а последовательность указанной длины (если найдена) в файл `output.txt`. При отсутствии `input.txt` программа выведет "Failed to open file". Формат входного файла: `длина_последовательности строка`. Формат выходного файла: `последовательность`. Название файлов может быть любым, главное чтобы входной файл существовал.
![Fifth type (valid)](https://i.imgur.com/sqAopUz.png)
![Fifth type (invalid 1)](https://i.imgur.com/6a4ZbcF.png)
![Fifth type (invalid 2)](https://i.imgur.com/719AYWW.png)

Ключи (-f, -g) проверяются только в случае ввода, состоящего из 4 аргументов. 

### Оптимизации 
#### Память
Использованные опции компиляции для ассемблерной программы: `as main.asm -o asm_program.o && gcc asm_program.o -o asm_program` (см. файл `asm_program/compile_asm.sh`)

Использованные опции компиляции для программы на С: `gcc c_program.c -o c_program && gcc c_program.c -O0 -o c_program_O0 && gcc c_program.c -O1 -o c_program_O1 && gcc c_program.c -O2 -o c_program_O2 && gcc c_program.c -O3 -o c_program_O3 && gcc c_program.c -Ofast -o c_program_Ofast && gcc c_program.c -Os -o c_program_Os` (см. файл `c_program/c_program_optimizations/compile_all_optimizations.sh`)

Использование разных опций компиляции незначительно уменьшюат место, занимаемое программой (кроме `-Ofast`)

![Memory](https://i.imgur.com/1bNF7uQ.png)

Примечательно, что компиляция с флагом `-0s`, направленная на уменьшение размера исполняемого файла, тоже не отличается особенным приростом.

![Memory on -Os](https://i.imgur.com/xtshAVB.png)

Самый большой объем оказался у программы, написанной на ассемблере, она проигрывает `-Ofast` на 1 килобайт.

![Memory on asm](https://i.imgur.com/KwIDFDs.png)

#### Ассемблерный листинг
Программа, написанная вручную на ассемблере максимально использует регистры, что значительно ускоряет время работы. Смысла сравнивать ассемблерный листинг Сишной программы с разными опциями компиляции просто нет, поскольку там компилятор не пытается использовать векторные инструкции, а также пытается использовать регистры.

#### Время
Замерять исполнение целой программы не очень корректно, даже в случае когда ввод/вывод осуществляется с помощью файлов, поскольку это очень времязатратная операция, поэтому будем тестировать функцию *find_sequence*, которая ищет последовательность указанной длины. Для этого нужно создать объектные файлы, в которых каждая функция скомпилированы с разными оптимизациями.  

Для ассемблерной программы возьмем файл *sequence.asm* из папки *asm_program*, добавим в его начале ```.global check_sequence .global find_sequence``` (чтобы функция была доступна при линковке из-вне), а затем создадим объектный файл командой `as -msyntax=intel -mnaked-reg sequence.asm -o sequence.o` (либо запустим скрипт `./create_sequence_object_file.sh`). Перенесем полученный файл в папку *run_tests*.  

Для программы на С создадим разные файлы в папке *c_program/sequence_object_files*, в которых название функции и файла будет отражать уровень оптимизаций. Создадим объектные файлы, запустив скрипт `./prepare_object_files.sh` (см. этот скрипт, чтобы увидеть все команды). Затем переместим полученные объектные файлы в папку *run_tests*.

Теперь нужно написать небольшую программу на С++, которая будет брать функции из объектных файлов и тестировать их. Подробный код доступен в исходном файле *run_tests.cpp*. Скомпилировать его, чтобы подтянуть функции можно командой `g++ -std=c++2a run_tests.cpp sequence_asm.o sequence_C_st.o sequence_C_O0.o sequence_C_O1.o sequence_C_O2.o sequence_C_O3.o sequence_C_Ofast.o -o run_tests` (или запустить скрипт `./compile_tester.sh`).

Данная программа тестирует функции на наборе входных данных несколько раз, выдает среднее значение в миллисекундах на протестированном наборе, а также отклонение среднего значения от максимального в процентах. Для более точного результата используются большие сгенерированные строки:
1) Размер строки 1 миллион символов, размер искомой последовательности 10 символов, тестируется 25 раз
2) Размер строки 10 миллион символов, размер искомой последовательности 25 символов, тестируется 10 раз
3) Размер строки 100 миллион символов, размер искомой последовательности 50 символов, тестируется 5 раз

Если вы желаете перепроверить работу программы, убедитесь что на вашей системе есть возможность выделения до 2 гигабайт памяти с помощью malloc. Если вы не можете выделить столько памяти, то в исходном коде тестирующей программы достаточно заменить размер генерируемой строки в функции main.

![main.cpp](https://i.imgur.com/spDhD7x.png)

Запустим программу - `./run_tests`

![Test results](https://i.imgur.com/JYbtSfE.png)

Как можем видеть, написанная на ассемблере вручную программа держится на равне с оптимизацией `-O1`. Но, уже можно видеть, что для такой задачи к ручному написанию кода на ассемблере прибегать смысла немного, поскольку прирост от оптимизаций компилятора куда больше.

### Файловые наборы тестовых данных (случайные и ручные)
Файлы с тестовыми данными и выводом находятся в папке *run_tests/file_tests*

### Случайные наборы тестовых данных
Файлы с результатом работы на случайных наборах находятся в папке *run_tests/random_tests*