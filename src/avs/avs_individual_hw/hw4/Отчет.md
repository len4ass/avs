## Отчет об ИДЗ #4, вариант 9

### Формализация алгоритма
![Algo](https://i.imgur.com/u0b4HHi.png)

Из задания понятно, что нам нужно создать два потока, каждый из которых будет работать со своей очередью. Поскольку нам требуется логировать информацию об обслуживании покупателей, то также потребуется файл, в который будет производиться вывод из каждого из потоков. Здесь возникнет проблема борьбы за ресурсы, которую мы решим созданием мьютекса, который будет блокироваться при каждой попытке записи в файл. 
Реализуем данный алгоритм на языке С++. В программу будет поступать общая очередь, которая затем делится на две ~равные по размеру, каждая из которых будет отдаваться своему потоку.

### Варианты вывода
При запуске на одном и том же наборе данных, вариантов вывода `2 * (n / 2)!`, где n - размер изначальной очереди. Это строго зависит от того, какой поток первым добрался до файла.

Далее следует несколько вариантов вывода для набора из 10 покупателей с идентификаторами 1, 2, 3, 4, 5, 6, 7, 8, 9, 10

![First](https://i.imgur.com/8hDNUZL.png)
![Second](https://i.imgur.com/lLCTLc3.png)


### Примечание
Исходный код и скомпилированная программа на С++ находится в папке *c_program*, скомпилировать самостоятельно ее можно зайдя в папку *c_program* и запустив скрипт `./compile.sh` (либо запустить уже скомпилированную программу `./out`).

Компиляция выполнялась на WSL2 Ubuntu с помощью `g++` (gcc for C++), убедитесь что у вас установлено данное дополнение для gcc, если вы хотите скомпилировать программу самостоятельно.

**P.S.:**
1) Выполнены требования на восемь баллов, исходный код программы дотошно прокомментирован
2) Сначала заполняется основная очередь, затем разделяется на две, а уже потом идет параллельное обслуживание покупателей
3) Минимальный размер очереди 2, максимальный - 1000000

### How to use
Есть несколько способов запуска программы:
1) `./out -g` - запуск программы, при котором генерируется размер основной очереди в диапазоне [2, 1000000], а также само случайное наполнение очереди идентификаторами, где каждый из идентификаторов лежит в диапазоне [1, size], где size - размер очереди. После генерации очередь будет записана в файл `generated_queue.txt` в формате `size id_1 id_2 ... id_n`. Результат обслуживания очереди будет в записываться в файл `parallel_output.txt`. 
![First type (valid)](https://i.imgur.com/cqvSlcK.png)
![First type (output)](https://i.imgur.com/g3nOuru.png)
2) `./out -g maximum` - запуск программы, при котором генерируется размер основной очереди в диапазоне [2, maximum]. а также само случайное наполнение очереди идентификаторами, где каждый из идентификаторов лежит в диапазоне [1, size], где size - размер очереди. После генерации очередь будет записана в файл `generated_queue.txt` в формате `size id_1 id_2 ... id_n`. Результат обслуживания очереди будет в записываться в файл `parallel_output.txt`. В случае если введенная верхняя граница меньше 0 или больше 1000000, будет выдана ошибка.
![Second type (valid)](https://i.imgur.com/V2BuFP5.png)
![Second type (output)](https://i.imgur.com/SmdizqJ.png)
![Second type (invalid 1)](https://i.imgur.com/JCsA5em.png)
![Second type (invalid 2)](https://i.imgur.com/vs4lpUG.png)
3) `./out -g minimum maximum` - запуск программы, при котором генерируется размер основной очереди в диапазоне [minimum, maximum]. а также само случайное наполнение очереди идентификаторами, где каждый из идентификаторов лежит в диапазоне [1, size], где size - размер очереди. После генерации очередь будет записана в файл `generated_queue.txt` в формате `size id_1 id_2 ... id_n`. Результат обслуживания очереди будет в записываться в файл `parallel_output.txt`. В случае если введенная нижняя/верхняя граница меньше 0 или больше 1000000, будет выдана ошибка. Если нижняя граница больше верхней, то тоже будет выдана ошибка.
![Third type (valid)](https://i.imgur.com/dOYy3ss.png)
![Third type (output)](https://i.imgur.com/Py96bLK.png)
![Fourth type (invalid 1)](https://i.imgur.com/KsLxsJd.png)
![Fourth type (invalid 2)](https://i.imgur.com/TkmaWnZ.png)
![Fourth type (invalid 3)](https://i.imgur.com/WWDl94Z.png)
4) `./out -f input.txt output.txt` - запуск программы, при котором общий размер очереди а также идентификаторы покупателей подаются из файла `input.txt`, а результат обслуживания логируется в файл `output.txt`. Формат ввода: `queue_size id_1 id_2 ... id_n`. Название файлов не имеет значения, главное чтобы файл ввода существовал, иначе будет выдана ошибка.
![Fourth type (valid)](https://i.imgur.com/ydYsmrG.png)
![Fourth type (invalid 1)](https://i.imgur.com/3V1GjHi.png)
5) `./out` - запуск программы в режиме работы с консоли, в котором вас попросят ввести размер очереди, а затем идентификаторы покупаталей.
![Fifth type (valid)](https://i.imgur.com/SHxR4Q0.png)
![Fifth type (output)](https://i.imgur.com/XqrGqwy.png)
![Fifth type (invalid)](https://i.imgur.com/R7i0cSg.png)
6) `./out < input.txt` - запуск программы в режиме перенаправления потока ввода с файла в консоль.
![Sixth type (valid)](https://i.imgur.com/vYD8JBA.png)
![Sixth type (output)](https://i.imgur.com/laGpheV.png)

Ключи (-f, -g) проверяются только в случае ввода, состоящего из 4 аргументов. 


### Файловые наборы тестовых данных
Файлы с тестовыми данными и выводом находятся в папке *c_program/file_tests*

### Случайные наборы тестовых данных
Файлы с результатом работы на случайных наборах находятся в папке *c_program/random_tests*