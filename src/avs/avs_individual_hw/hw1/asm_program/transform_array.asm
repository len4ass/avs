.text
    .type   transform_array, @function

    transform_array:
        push rbp                                # Пролог
        mov rbp, rsp
        
        push rdi                                # Сохраняем rdi и rsi перед вызовом malloc
        push rsi
                                 
        mov rdi, rsi                            # Кладем размер массива в rdi (первый аргумент malloc)
        sal rdi, 3                              # Умножаем размер массива на 8 битовым сдвигом влево (получим кол-во байт которое нам нужно выделить)           
        call malloc@plt                         # Вызываем malloc
   
        pop rsi                                 # Восстанавливаем rdi и rsi
        pop rdi
   
        mov rcx, 1                              # Ставим переменную цикла по старому массива равной 1 (идем по нечетным индексам)
        xor edx, edx                            # Зануляем переменную цикла по новому массиву (сначала записываем нечетные элементы)
        .loop_odd_start:
            cmp rcx, rsi                        # Сравнение переменной цикла по старому массиву с его размером
            jge .loop_odd_end
            cmp rdx, rsi                        # Сравнение переменной цикла нового массива с его размером
            jge .loop_odd_end                   # Если хотя бы одна из переменных цикла >= размера массива, то прыгаем на конец цикла
    
            mov r8, qword ptr[rdi + 8 * rcx]    # Перемещаем в r8 значение старого массива на позиции rcx <=> element = *((qword*)(rdi + 8 * rcx))
            mov qword ptr[rax + 8 * rdx], r8    # Перемещаем значение из r8 в новый массив на позицию rdx <=> *((qword*)(rax + 8 * rdx)) = r8
    
            add rcx, 2                          # Смещаем переменную цикла по старому массиву на следующее нечетное число     
            inc rdx                             # Увеличиваем переменную цикла по новому массиву на один
            jmp .loop_odd_start                 # Прыгаем на начало цикла
        .loop_odd_end:
    
        xor ecx, ecx                            # Зануляем переменную цикла по старому массиву (теперь идем по четным индексам)
        mov rdx, rsi                            # Перемещаем размер в переменную цикла по новому массиву
        sar rdx, 1                              # Целочисленно делим на два размер массива побитовым сдвигом (мы заполнили [половину] массива элементами на нечетных индексах)
    
        .loop_even_start:
            cmp rcx, rsi                        # Сравнение переменной цикла по старому массиву с его размером
            jge .loop_even_end
            cmp rdx, rsi                        # Сравнение переменной цикла нового массива с его размером
            jge .loop_even_end                  # Если хотя бы одна из переменных цикла >= размера массива, то прыгаем на конец цикла
    
            mov r8, qword ptr[rdi + 8 * rcx]    # Перемещаем в r8 значение старого массива на позиции rcx <=> element = *((qword*)(rdi + 8 * rcx))
            mov qword ptr[rax + 8 * rdx], r8    # Перемещаем значение из r8 в новый массив на позицию rdx <=> *((qword*)(rax + 8 * rdx)) = r8
    
            add rcx, 2                          # Смещаем переменную цикла по старому массиву на следующее нечетное число     
            inc rdx                             # Увеличиваем переменную цикла по новому массиву на один
            jmp .loop_even_start                # Прыгаем на начало цикла
        .loop_even_end:
    
        leave                                   # Эпилог
        ret
