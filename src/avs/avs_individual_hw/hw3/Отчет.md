## Отчет об ИДЗ #2, вариант 27

### Примечание
Программа изначально написана на ассемблере (вручную). Затем была написана аналогичная программа на С.
Исходный код и скомпилированная программа на ассемблере находится в папке *asm_program*, скомпилировать самостоятельно ее можно зайдя в папку *asm_program* и запустив скрипт `./compile_asm.sh` (либо запустить уже скомпилированную программу `./asm_program`).

Исходный код и скомпилированная программа на С находится в папке *c_program/c_program_optimizations*, скомпилировать ее можно либо с помощью gcc `gcc c_program.c -o c_program`, либо запустив скрипт `./compile_all_optimizations.sh` -- он выдаст программы с разными уровнями оптимизации (либо запустить уже скомпилированную программу `./c_program`).

Компиляция выполнялась на WSL2 Ubuntu с помощью `as`, `gcc` и `g++` для тестирующей программы.

**P.S.:**
1) **Важно понимать, что сохранение высокой точности НЕВОЗМОЖНО при задании больших пределов интегрирования или больших коэффициентов в виду того, как в памяти представляются 64 битные вещественные числа! Точность 0.0001 при интегрировании с разницей между пределами 100000 и более, или при больших коэффициентах не гарантируется.**
2) Выполнены требования на 9 баллов, каждая строчка ассемблерной программы прокомментирована  
3) Для полной корректной работы всех программ и репликации результатов тестов требуется процессор с поддержкой AVX2/SSE инструкции
4) При использовании генератора, переданные значения используются как границы генерации значений a и b интегрируемой функции, а сами переданные значения выступают как пределы интегрирования.

### How to use
Есть несколько способов запуска программы:
1) `./asm_program` - стандартный запуск программы, при котором от пользователя потребуется ввести коэффициенты функции a и b, а также нижний и верхний предел интегрирования. После исполнения будет выведен результат интегрирования в консоль. Если пределы интегрирования заданы некорректно (нижний предел больше верхнего), то будет выдана соответствующая ошибка
![First type (valid)](https://i.imgur.com/XWuuJhx.png)
![First type (invalid 1)](https://i.imgur.com/P5mPLVp.png)
2) `./asm_program -g` - запуск программы, при котором генерируются коэффициенты a и b, а также пределы интегрирования. Нижний предел интегрирования будет в диапазоне [0, 100], верхний в диапазоне [нижний предел, 100]. Коэффициент а будет в диапазоне [нижний предел, верхний предел]. Коэффициент b будет в диапазоне [коэффициент а, верхний предел]. После исполнения будут созданы файлы `generated.txt` и `result.txt`. В `generated.txt` будут лежать коэффициенты a и b, верхний и нижний предел интегрирования. Формат вывода: `a b lower_bound upper_bound`. В `result.txt` будет лежать результат интегрирования функции в формате `result`.
![Second type (valid)](https://i.imgur.com/YEfHUy4.png)
3) `./asm_program -g upper_bound` - запуск программы, при котором генерируются коэффициенты a и b. Верхний коэффициент интегрирования становится равен `upper_bound`, а нижний 0. Коэффициент а будет в диапазоне [нижний предел, верхний предел]. Коэффициент b будет в диапазоне [коэффициент а, верхний предел]. После исполнения будут созданы файлы `generated.txt` и `result.txt`. В `generated.txt` будут лежать коэффициенты a и b, верхний и нижний предел интегрирования. Формат вывода: `a b lower_bound upper_bound`. В `result.txt` будет лежать результат интегрирования функции в формате `result`.
![Third type (valid)](https://i.imgur.com/qIczaAD.png)
4) `./asm_program -g lower_bound upper_bound` - запуск программы, при котором генерируются коэффициенты a и b. Верхний коэффициент интегрирования становится равен `upper_bound`, а нижний `lower_bound`. Если нижний предел интегрирования больше верхнего, будет выдана соответствующая ошибка. Коэффициент а будет в диапазоне [нижний предел, верхний предел]. Коэффициент b будет в диапазоне [коэффициент а, верхний предел]. После исполнения будут созданы файлы `generated.txt` и `result.txt`. В `generated.txt` будут лежать коэффициенты a и b, верхний и нижний предел интегрирования. Формат вывода: `a b lower_bound upper_bound`. В `result.txt` будет лежать результат интегрирования функции в формате `result`.
![Fourth type (valid)](https://i.imgur.com/ELALbm1.png)
![Fourth type (invalid 1)](https://i.imgur.com/bGjyrOz.png)
5) `./asm_program -f input.txt output.txt` - запуск программы, при котором коэффициенты a и b, а также нижний и верхний предел интегрирования подаются через файл `input.txt`. Если нижний предел интегрирования больше верхнего, будет выдана соответствующая ошибка. После исполнения результат интегрирования будет записан в файл `output.txt`. Формат ввода: `a b lower_bound upper_bound`. Формат вывода: `result`. Название файлов не имеет значения, главное чтобы файл ввода существовал, иначе будет выдана ошибка.
![Fifth type (valid)](https://i.imgur.com/uPGpesl.png)
![Fifth type (invalid 1)](https://i.imgur.com/c9M5mEe.png)
![Fifth type (invalid 2)](https://i.imgur.com/5UqvqUk.png)

Ключи (-f, -g) проверяются только в случае ввода, состоящего из 4 аргументов. 

### Оптимизации 
#### Память
Использованные опции компиляции для ассемблерной программы: `as main.asm -o asm_program.o && gcc asm_program.o -o asm_program` (см. файл `asm_program/compile_asm.sh`)

Использованные опции компиляции для программы на С: `gcc c_program.c -o c_program && gcc c_program.c -O0 -o c_program_O0 && gcc c_program.c -O1 -o c_program_O1 && gcc c_program.c -O2 -o c_program_O2 && gcc c_program.c -O3 -o c_program_O3 && gcc c_program.c -Ofast -o c_program_Ofast && gcc c_program.c -Os -o c_program_Os` (см. файл `c_program/c_program_optimizations/compile_all_optimizations.sh`)

Использование разных опций компиляции незначительно уменьшают место, занимаемое программой (кроме `-Ofast`)

![Memory](https://i.imgur.com/1ImgWXI.png)

Примечательно, что компиляция с флагом `-0s`, направленная на уменьшение размера исполняемого файла, тоже не отличается особенным приростом, наоборот, становится больше на 32 байта нежели программа, скомпилированная с `-O0`.

![Memory on -Os](https://i.imgur.com/HFyboDP.png)

Самый большой объем оказался у программы, скомпилированной с флагом `-Ofast`, она проигрывает ассемблеру больше чем на 3.5 килобайта.

![Memory on Ofast](https://i.imgur.com/d8uP75v.png)

#### Ассемблерный листинг
Программа, написанная вручную на ассемблере максимально использует регистры, что значительно ускоряет время работы. Смысла сравнивать ассемблерный листинг Сишной программы с разными опциями компиляции просто нет, поскольку там компилятор не пытается использовать векторные инструкции, а также пытается использовать регистры.

#### Время
Замерять исполнение целой программы не очень корректно, даже в случае когда ввод/вывод осуществляется с помощью файлов, поскольку это очень времязатратная операция, поэтому будем тестировать функцию *integrate*, которая интегрирует функцию с указанными коэффициентами на указанном промежутке. Для этого нужно создать объектные файлы, в которых каждая функция скомпилированы с разными оптимизациями.  

Для ассемблерной программы возьмем файл *integrate.asm* из папки *asm_program*, добавим в его начале ```.global integrate``` (чтобы функция была доступна при линковке из-вне), а затем создадим объектный файл командой `as -msyntax=intel -mnaked-reg integrate.asm -o integrate.o` (либо запустим скрипт `./create_sequence_object_file.sh`). Перенесем полученный файл в папку *run_tests*.  

Для программы на С создадим разные файлы в папке *c_program/integrate_object_files*, в которых название функции и файла будет отражать уровень оптимизаций. Создадим объектные файлы, запустив скрипт `./prepare_object_files.sh` (см. этот скрипт, чтобы увидеть все команды). Затем переместим полученные объектные файлы в папку *run_tests*.

Теперь нужно написать небольшую программу на С++, которая будет брать функции из объектных файлов и тестировать их. Подробный код доступен в исходном файле *run_tests.cpp*. Скомпилировать его, чтобы подтянуть функции можно командой `g++ -std=c++2a run_tests.cpp integrate_asm.o integrate_C_st.o integrate_C_O0.o integrate_C_O1.o integrate_C_O2.o integrate_C_O3.o integrate_C_Ofast.o -o run_tests` (или запустить скрипт `./compile_tester.sh`).

Данная программа тестирует функции на наборе входных данных несколько раз, выдает среднее значение в миллисекундах на протестированном наборе, а также отклонение среднего значения от максимального в процентах. Для более точного результата используются большие пределы интегрирования:
1) Разница между пределами интегрирования 1000, количество разбиений 1000000, 25 тестов
2) Разница между пределами интегрирования 10000, количество разбиений 10000000, 10 тестов
3) Разница между пределами интегрирования 100000, количество разбиений 100000000, 5 тестов

Если вы желаете перепроверить работу программы, убедитесь что на вашей системе поддерживаются AVX2/SSE инструкции.

![main.cpp](https://i.imgur.com/sFczz1l.png)

Запустим программу - `./run_tests`

![Test results](https://i.imgur.com/AbBh6af.png)

Как можем видеть, написанная на ассемблере вручную программа работает значительно быстрее программы с оптимизацией `-00`, и наравне с `-01, -02, -03`, но чуть медленнее `-0fast`. Можем сделать вывод, что это замечательный результат для программы написанной на ассемблере вручную.

### Файловые наборы тестовых данных (случайные и ручные)
Файлы с тестовыми данными и выводом находятся в папке *run_tests/file_tests*

### Случайные наборы тестовых данных
Файлы с результатом работы на случайных наборах находятся в папке *run_tests/random_tests*